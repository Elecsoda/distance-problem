<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¡Œç¨‹é—®é¢˜æ¼”ç¤ºå·¥å…·</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Comic Sans MS', 'Ma Shan Zheng', 'Segoe UI', Roboto, sans-serif; background-color: #fffbeb; touch-action: manipulation; }
        .track-bg { background-color: #ffffff; border-radius: 16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .tabular-nums { font-variant-numeric: tabular-nums; }
        .no-select { user-select: none; -webkit-user-select: none; }
        .height-transition { transition: height 0.3s ease-out; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 640px) {
            .mobile-stack { flex-direction: column; }
            .mobile-full { width: 100%; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- å›¾æ ‡ ---
        const Icon = ({ path, size=20 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                {path}
            </svg>
        );
        const Icons = {
            Play: <polygon points="5 3 19 12 5 21 5 3" />,
            Pause: <g><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></g>,
            Reset: <g><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></g>,
            Continue: <path d="M13 5l7 7-7 7M5 12h14" />
        };

        // é»˜è®¤å‚æ•°å¸¸é‡
        const DEFAULTS = {
            distance: 400,
            speedA: 50,
            speedB: 30,
            headStart: 100
        };

        const App = () => {
            // --- çŠ¶æ€ ---
            const [mode, setMode] = useState('meeting'); 
            
            // åŸºç¡€å‚æ•°
            const [distance, setDistance] = useState(DEFAULTS.distance); 
            const [speedA, setSpeedA] = useState(DEFAULTS.speedA); 
            const [speedB, setSpeedB] = useState(DEFAULTS.speedB); 
            const [headStart, setHeadStart] = useState(DEFAULTS.headStart); 

            // æ¼”ç¤ºæ§åˆ¶
            const [simSpeed, setSimSpeed] = useState(1); 
            const [showMarkers, setShowMarkers] = useState(true);

            // å®æ—¶çŠ¶æ€
            const [posA, setPosA] = useState(0); 
            const [posB, setPosB] = useState(0); 
            const [dirA, setDirA] = useState(1); 
            const [dirB, setDirB] = useState(-1);
            const [totalDistA, setTotalDistA] = useState(0); 
            const [totalDistB, setTotalDistB] = useState(0);
            const [currentTime, setCurrentTime] = useState(0); 
            const [meetCount, setMeetCount] = useState(0);
            
            // è½¨è¿¹ä¸å†å²
            const [turnPointsA, setTurnPointsA] = useState([]);
            const [turnPointsB, setTurnPointsB] = useState([]);
            const [meetingHistory, setMeetingHistory] = useState([]);
            
            const [isRunning, setIsRunning] = useState(false);
            const [isPausedAtEvent, setIsPausedAtEvent] = useState(false);

            const requestRef = useRef();
            const lastTimeRef = useRef();
            
            // ç‰©ç†çŠ¶æ€æ ¸å¿ƒ
            const physicsState = useRef({ 
                posA: 0, posB: 0, 
                dirA: 1, dirB: -1, 
                totalDistA: 0, totalDistB: 0, 
                time: 0,
                turnsA: [], turnsB: []
            });

            // --- é‡ç½® ---
            // resetParams: æ˜¯å¦é‡ç½®è·ç¦»/é€Ÿåº¦ç­‰å‚æ•°
            const resetPositions = (targetMode = mode, resetParams = false) => {
                setIsRunning(false);
                setIsPausedAtEvent(false);
                setCurrentTime(0);
                setMeetCount(0);
                setMeetingHistory([]);
                lastTimeRef.current = undefined;

                // å¦‚æœéœ€è¦é‡ç½®å‚æ•°
                let currentDist = distance;
                let currentHeadStart = headStart;
                
                if (resetParams) {
                    setDistance(DEFAULTS.distance);
                    setSpeedA(DEFAULTS.speedA);
                    setSpeedB(DEFAULTS.speedB);
                    setHeadStart(DEFAULTS.headStart);
                    currentDist = DEFAULTS.distance;
                    currentHeadStart = DEFAULTS.headStart;
                }

                let startA = 0;
                let startB = 0;
                let dA = 1;
                let dB = -1;

                if (targetMode === 'meeting') {
                    startA = 0; startB = currentDist; dA = 1; dB = -1;
                } else { 
                    startA = 0; startB = currentHeadStart; dA = 1; dB = 1;
                }

                const initTurnsA = [{ pos: startA, totalDist: 0 }];
                const initTurnsB = [{ pos: startB, totalDist: 0 }];

                setPosA(startA); setPosB(startB);
                setDirA(dA); setDirB(dB);
                setTotalDistA(0); setTotalDistB(0);
                setTurnPointsA(initTurnsA);
                setTurnPointsB(initTurnsB);

                physicsState.current = { 
                    posA: startA, posB: startB, 
                    dirA: dA, dirB: dB, 
                    totalDistA: 0, totalDistB: 0, 
                    time: 0,
                    turnsA: JSON.parse(JSON.stringify(initTurnsA)), 
                    turnsB: JSON.parse(JSON.stringify(initTurnsB))
                };
            };

            // ä»…å‚æ•°å˜åŒ–æ—¶é‡ç½®ä½ç½®(ä¸é‡ç½®å‚æ•°æœ¬èº«)
            useEffect(() => {
                if (!isRunning && !isPausedAtEvent) resetPositions(mode, false);
            }, [distance, headStart]); // ä¾èµ–é¡¹ä¸åŒ…å« speedA/B å› ä¸ºé€Ÿåº¦æ”¹å˜ä¸éœ€è¦é‡ç½®ä½ç½®

            // æ¨¡å¼åˆ‡æ¢ï¼šå½»åº•åˆå§‹åŒ–
            const handleModeChange = (newMode) => {
                setMode(newMode);
                // ä¼ å…¥ true è¡¨ç¤ºé‡ç½®æ‰€æœ‰å‚æ•°
                resetPositions(newMode, true);
            };

            // --- ç‰©ç†å¼•æ“ ---
            const loop = (timestamp) => {
                if (!lastTimeRef.current) lastTimeRef.current = timestamp;
                const rawDt = (timestamp - lastTimeRef.current) / 1000;
                lastTimeRef.current = timestamp;
                
                let timeLeft = Math.min(rawDt, 0.1) * simSpeed;
                let state = physicsState.current;
                
                let hasPaused = false;

                while (timeLeft > 0.00001 && !hasPaused) {
                    const { posA, posB, dirA, dirB } = state;
                    const vA = speedA * dirA;
                    const vB = speedB * dirB;

                    let tWallA = Infinity;
                    let tWallB = Infinity;

                    if (mode === 'meeting') {
                        if (dirA === 1) tWallA = (distance - posA) / speedA;
                        else tWallA = posA / speedA;

                        if (dirB === 1) tWallB = (distance - posB) / speedB;
                        else tWallB = posB / speedB;
                    }

                    let tCol = Infinity;
                    const relV = vA - vB;
                    const relPos = posB - posA;
                    
                    if (Math.abs(relV) > 1e-9) {
                        const t = relPos / relV;
                        if (t > 1e-6) tCol = t;
                    }

                    const events = [
                        { type: 'wallA', t: tWallA },
                        { type: 'wallB', t: tWallB },
                        { type: 'col', t: tCol }
                    ].filter(e => e.t <= timeLeft);

                    events.sort((a, b) => a.t - b.t);
                    const nextEvent = events[0];

                    const step = nextEvent ? nextEvent.t : timeLeft;
                    
                    state.posA += vA * step;
                    state.posB += vB * step;
                    state.totalDistA += speedA * step;
                    state.totalDistB += speedB * step;
                    state.time += step;
                    
                    timeLeft -= step;

                    if (nextEvent) {
                        if (nextEvent.type === 'wallA') {
                            state.posA = (dirA === 1) ? distance : 0;
                            state.dirA *= -1;
                            if (state.turnsA.at(-1).pos !== state.posA) {
                                state.turnsA.push({ pos: state.posA, totalDist: state.totalDistA });
                            }
                        } else if (nextEvent.type === 'wallB') {
                            state.posB = (dirB === 1) ? distance : 0;
                            state.dirB *= -1;
                            if (state.turnsB.at(-1).pos !== state.posB) {
                                state.turnsB.push({ pos: state.posB, totalDist: state.totalDistB });
                            }
                        } else if (nextEvent.type === 'col') {
                            state.posA = state.posB = (state.posA + state.posB) / 2;
                            hasPaused = true; 
                            setIsRunning(false);
                            setIsPausedAtEvent(true);
                            const newCount = meetCount + 1;
                            setMeetCount(newCount);
                            setMeetingHistory(prev => [...prev, {
                                count: newCount,
                                pos: state.posA,
                                totalDistA: state.totalDistA,
                                totalDistB: state.totalDistB,
                                time: state.time
                            }]);
                        }
                    }
                }

                setPosA(state.posA); setPosB(state.posB);
                setDirA(state.dirA); setDirB(state.dirB);
                setTotalDistA(state.totalDistA); setTotalDistB(state.totalDistB);
                setCurrentTime(state.time);
                if (turnPointsA.length !== state.turnsA.length) setTurnPointsA([...state.turnsA]);
                if (turnPointsB.length !== state.turnsB.length) setTurnPointsB([...state.turnsB]);

                if (!hasPaused) {
                    requestRef.current = requestAnimationFrame(loop);
                } else {
                    lastTimeRef.current = undefined;
                }
            };

            useEffect(() => {
                if (isRunning) requestRef.current = requestAnimationFrame(loop);
                else { cancelAnimationFrame(requestRef.current); lastTimeRef.current = undefined; }
                return () => cancelAnimationFrame(requestRef.current);
            }, [isRunning, simSpeed]);

            const handleContinue = () => {
                const nudge = 0.05; 
                let state = physicsState.current;
                state.posA += speedA * state.dirA * nudge;
                state.posB += speedB * state.dirB * nudge;
                state.totalDistA += speedA * nudge;
                state.totalDistB += speedB * nudge;
                state.time += nudge; 
                
                if(state.posA > distance) state.posA = distance; 
                if(state.posA < 0) state.posA = 0;
                
                setPosA(state.posA); setPosB(state.posB);
                setTotalDistA(state.totalDistA); setTotalDistB(state.totalDistB);
                setCurrentTime(state.time);
                
                setIsPausedAtEvent(false);
                setIsRunning(true);
            };

            const viewMax = (mode === 'catching') 
                ? Math.max(distance + 100, posA + 100, posB + 100)
                : distance;

            const blueBaseY = 35;
            const lineHeight = 20; 
            const blueLinesCount = turnPointsA.length;
            const blueMaxY = blueBaseY + (blueLinesCount - 1) * lineHeight;
            const redBaseY = Math.max(blueBaseY + 40, blueMaxY + 30);
            const redLinesCount = turnPointsB.length;
            const redMaxY = redBaseY + (redLinesCount - 1) * lineHeight;
            const dynamicContainerHeight = Math.max(260, redMaxY + 100);

            const renderMarkers = (track, segmentStart, segmentEnd, startX, endX, y) => {
                if (!showMarkers) return null;
                const minD = Math.min(segmentStart, segmentEnd);
                const maxD = Math.max(segmentStart, segmentEnd);

                return meetingHistory.filter(m => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    return d >= minD - 0.01 && d <= maxD + 0.01;
                }).map((m, i) => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    let ratio = 0;
                    if (Math.abs(segmentEnd - segmentStart) > 0.01) {
                        ratio = (d - segmentStart) / (segmentEnd - segmentStart);
                    }
                    const mx = startX + ratio * (endX - startX);
                    
                    return (
                        <g key={i}>
                            <circle cx={`${(mx/viewMax)*100}%`} cy={y} r="3" fill="red" stroke="white" strokeWidth="1" />
                            <text x={`${(mx/viewMax)*100}%`} y={y - 7} fontSize="8" fill="red" textAnchor="middle" fontWeight="bold">
                                {m.count}
                            </text>
                            <text x={`${(mx/viewMax)*100}%`} y={y + 9} fontSize="7" fill="#666" textAnchor="middle">
                                {Math.round(d)}m
                            </text>
                            <text x={`${(mx/viewMax)*100}%`} y={y + 17} fontSize="7" fill="#999" textAnchor="middle">
                                {m.time.toFixed(1)}s
                            </text>
                        </g>
                    );
                });
            };

            return (
                <div className="min-h-screen p-2 md:p-8 max-w-4xl mx-auto flex flex-col">
                    <header className="mb-4 text-center">
                        <h1 className="text-2xl md:text-4xl font-bold text-amber-600 mb-2">ğŸƒ è¡Œç¨‹é—®é¢˜æ¼”ç¤ºå·¥å…·</h1>
                        <p className="text-xs md:text-base text-stone-500 font-bold">
                            {mode === 'meeting' ? 'ç›¸é‡é—®é¢˜ï¼šé¢å¯¹é¢è·‘ï¼Œçœ‹è°è·‘å¾—å¿«' : 'è¿½åŠé—®é¢˜ï¼šåœ¨åé¢è¿½ï¼Œçœ‹èƒ½ä¸èƒ½è¿½ä¸Š'}
                        </p>
                    </header>

                    {/* æ§åˆ¶é¢æ¿ */}
                    <div className="bg-white p-3 md:p-6 rounded-2xl shadow-lg border-2 border-amber-100 mb-4 select-none">
                        <div className="flex justify-center gap-4 mb-4">
                            <button onClick={() => handleModeChange('meeting')} className={`px-4 py-2 md:px-6 rounded-xl font-bold text-sm md:text-lg transition-all active:scale-95 ${mode === 'meeting' ? 'bg-amber-400 text-white shadow-md' : 'bg-stone-100 text-stone-500'}`}>
                                ğŸ¤ ç›¸é‡é—®é¢˜
                            </button>
                            <button onClick={() => handleModeChange('catching')} className={`px-4 py-2 md:px-6 rounded-xl font-bold text-sm md:text-lg transition-all active:scale-95 ${mode === 'catching' ? 'bg-purple-400 text-white shadow-md' : 'bg-stone-100 text-stone-500'}`}>
                                ğŸ¢ è¿½åŠé—®é¢˜
                            </button>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-3">
                            {/* è·ç¦» */}
                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸ {mode === 'catching' ? 'è·‘é“æ˜¾ç¤ºé•¿åº¦' : 'ä¸¤åœ°è·ç¦»'}</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={distance} onChange={(e) => setDistance(Math.max(10, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-amber-600 border-amber-200 focus:outline-none focus:border-amber-500 text-sm" />
                                        <span className="text-amber-600 text-xs md:text-sm">ç±³</span>
                                    </div>
                                </label>
                                <input type="range" min="100" max="2000" step="50" value={distance} onChange={e => setDistance(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-amber-500 cursor-pointer h-6" />
                            </div>

                            {/* è¿½åŠå…ˆè·‘ */}
                            {mode === 'catching' && (
                                <div className="space-y-1">
                                    <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                        <span>ğŸ“ å°çº¢å…ˆè·‘ (å·®è·)</span>
                                        <div className="flex items-center gap-1">
                                            <input type="number" value={headStart} onChange={(e) => setHeadStart(Math.max(0, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-purple-600 border-purple-200 focus:outline-none focus:border-purple-500 text-sm" />
                                            <span className="text-purple-600 text-xs md:text-sm">ç±³</span>
                                        </div>
                                    </label>
                                    <input type="range" min="0" max="1000" step="10" value={headStart} onChange={e => setHeadStart(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-purple-500 cursor-pointer h-6" />
                                </div>
                            )}
                            
                            {mode !== 'catching' && <div className="hidden md:block"></div>}

                            {/* ç”²é€Ÿåº¦ */}
                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸƒâ€â™‚ï¸ å°æ˜é€Ÿåº¦</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={speedA} onChange={(e) => setSpeedA(Math.max(1, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-blue-600 border-blue-200 focus:outline-none focus:border-blue-500 text-sm" />
                                        <span className="text-blue-600 text-xs md:text-sm">ç±³/ç§’</span>
                                    </div>
                                </label>
                                <input type="range" min="1" max="200" value={speedA} onChange={e => setSpeedA(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-blue-500 cursor-pointer h-6" />
                            </div>

                            {/* ä¹™é€Ÿåº¦ */}
                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸƒâ€â™€ï¸ å°çº¢é€Ÿåº¦</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={speedB} onChange={(e) => setSpeedB(Math.max(1, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-rose-500 border-rose-200 focus:outline-none focus:border-rose-500 text-sm" />
                                        <span className="text-rose-500 text-xs md:text-sm">ç±³/ç§’</span>
                                    </div>
                                </label>
                                <input type="range" min="1" max="200" value={speedB} onChange={e => setSpeedB(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-rose-400 cursor-pointer h-6" />
                            </div>
                        </div>

                        {/* åº•éƒ¨è®¾ç½® */}
                        <div className="mt-4 flex flex-wrap items-center justify-between border-t pt-4 border-stone-100 gap-2">
                            <div className="flex items-center gap-1 md:gap-2">
                                <span className="text-xs font-bold text-stone-400">å€é€Ÿ:</span>
                                {[0.5, 1, 2, 5].map(rate => (
                                    <button key={rate} onClick={() => setSimSpeed(rate)} className={`px-2 py-1 text-xs rounded border ${simSpeed === rate ? 'bg-stone-500 text-white border-stone-500' : 'bg-white text-stone-500 border-stone-200'}`}>
                                        {rate}x
                                    </button>
                                ))}
                            </div>

                            <label className="flex items-center gap-2 cursor-pointer">
                                <span className="text-xs font-bold text-stone-500">æ˜¾ç¤ºæ ‡è®°</span>
                                <div className={`w-9 h-5 rounded-full p-0.5 transition-colors duration-300 ${showMarkers ? 'bg-green-500' : 'bg-stone-300'}`} onClick={() => setShowMarkers(!showMarkers)}>
                                    <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform duration-300 ${showMarkers ? 'translate-x-4' : ''}`}></div>
                                </div>
                            </label>
                        </div>
                    </div>

                    {/* æ¼”ç¤ºåŒºåŸŸ */}
                    <div className="space-y-4 md:space-y-6">
                        <div className="track-bg p-4 md:p-6 relative overflow-hidden border-2 border-stone-100 select-none height-transition" style={{ height: `${dynamicContainerHeight}px` }}>
                            <div className="absolute top-3 left-4 text-stone-400 text-xs md:text-sm font-bold flex gap-2 z-20">
                                {isPausedAtEvent 
                                    ? <span className="text-green-600 text-sm md:text-lg animate-bounce inline-block">ğŸš© ç¬¬ {meetCount} æ¬¡{mode === 'meeting' ? 'ç›¸é‡' : 'è¿½ä¸Š'}ï¼</span> 
                                    : (isRunning ? 'ğŸƒ æ­£åœ¨å¥”è·‘...' : 'ğŸ å‡†å¤‡å‡ºå‘')}
                            </div>

                            <div className="relative w-full h-1.5 bg-stone-300 rounded-full mt-12 z-10">
                                <svg className="absolute left-0 top-0 w-full overflow-visible pointer-events-none" style={{ height: `${dynamicContainerHeight}px` }}>
                                    <defs>
                                        <marker id="arrow-blue" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#2563eb" /></marker>
                                        <marker id="arrow-red" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#e11d48" /></marker>
                                    </defs>

                                    {turnPointsA.map((pt, i) => {
                                        const startX = pt.pos;
                                        const endX = (i === turnPointsA.length - 1) ? posA : turnPointsA[i + 1].pos;
                                        const startTotal = pt.totalDist;
                                        const endTotal = (i === turnPointsA.length - 1) ? totalDistA : turnPointsA[i + 1].totalDist;
                                        if (Math.abs(endX - startX) < 1) return null;
                                        const yOffset = blueBaseY + i * lineHeight;
                                        
                                        return (
                                            <g key={`a-${i}`}>
                                                <line x1={`${(startX/viewMax)*100}%`} y1={yOffset} x2={`${(endX/viewMax)*100}%`} y2={yOffset} stroke="#2563eb" strokeWidth="2" markerEnd="url(#arrow-blue)" opacity="0.6" />
                                                <text x={`${((startX+endX)/2/viewMax)*100}%`} y={yOffset-3} fill="#2563eb" fontSize="10" textAnchor="middle">{Math.round(Math.abs(endX-startX))}m</text>
                                                {renderMarkers('A', startTotal, endTotal, startX, endX, yOffset)}
                                            </g>
                                        );
                                    })}

                                    {turnPointsB.map((pt, i) => {
                                        const startX = pt.pos;
                                        const endX = (i === turnPointsB.length - 1) ? posB : turnPointsB[i + 1].pos;
                                        const startTotal = pt.totalDist;
                                        const endTotal = (i === turnPointsB.length - 1) ? totalDistB : turnPointsB[i + 1].totalDist;
                                        if (Math.abs(endX - startX) < 1) return null;
                                        const yOffset = redBaseY + i * lineHeight;
                                        
                                        return (
                                            <g key={`b-${i}`}>
                                                <line x1={`${(startX/viewMax)*100}%`} y1={yOffset} x2={`${(endX/viewMax)*100}%`} y2={yOffset} stroke="#e11d48" strokeWidth="2" markerEnd="url(#arrow-red)" opacity="0.6" />
                                                <text x={`${((startX+endX)/2/viewMax)*100}%`} y={yOffset+12} fill="#e11d48" fontSize="10" textAnchor="middle">{Math.round(Math.abs(endX-startX))}m</text>
                                                {renderMarkers('B', startTotal, endTotal, startX, endX, yOffset)}
                                            </g>
                                        );
                                    })}
                                </svg>

                                {/* åˆ»åº¦ä¸äººç‰© */}
                                <div className="absolute left-0 -top-1 w-0.5 h-3 bg-stone-400"></div>
                                <div className="absolute left-0 -top-6 text-xs font-bold text-stone-500 -translate-x-1/2">0m</div>
                                {mode === 'meeting' && <><div className="absolute right-0 -top-1 w-0.5 h-3 bg-stone-400"></div><div className="absolute right-0 -top-6 text-xs font-bold text-stone-500 translate-x-1/2">{distance}m</div></>}
                                {mode === 'catching' && <><div className="absolute w-0.5 h-3 bg-purple-300 -top-1" style={{ left: `${(headStart/viewMax)*100}%` }}></div><div className="absolute text-xs font-bold text-purple-400 -top-6 -translate-x-1/2" style={{ left: `${(headStart/viewMax)*100}%` }}>{headStart}m</div></>}

                                <div className="absolute transition-none z-30" style={{ left: `${(posA/viewMax)*100}%`, top: '-50px', transform: `translateX(-50%) scaleX(${dirA===1?-1:1})` }}>
                                    <div className="flex flex-col items-center"><span className="text-4xl md:text-5xl filter drop-shadow-md">ğŸƒâ€â™‚ï¸</span><span className="text-[10px] font-bold text-blue-600 bg-white/90 px-1 rounded shadow-sm whitespace-nowrap" style={{transform:`scaleX(${dirA===1?-1:1})`}}>å°æ˜</span></div>
                                </div>
                                <div className="absolute transition-none z-20" style={{ left: `${(posB/viewMax)*100}%`, top: '-50px', transform: `translateX(-50%) scaleX(${dirB===1?-1:1})` }}>
                                    <div className="flex flex-col items-center"><span className="text-4xl md:text-5xl filter drop-shadow-md inline-block">ğŸƒâ€â™€ï¸</span><span className="text-[10px] font-bold text-rose-500 bg-white/90 px-1 rounded shadow-sm whitespace-nowrap" style={{transform:`scaleX(${dirB===1?-1:1})`}}>å°çº¢</span></div>
                                </div>
                            </div>
                        </div>

                        {/* æŒ‰é’® */}
                        <div className="flex gap-4 items-center">
                            <button onClick={() => {
                                if (isPausedAtEvent) { if (mode === 'meeting') handleContinue(); else resetPositions(mode, false); } 
                                else setIsRunning(!isRunning);
                            }} className={`flex-1 text-white text-base md:text-lg font-bold py-3 md:py-4 rounded-xl shadow-lg flex items-center justify-center gap-2 transition-transform active:scale-95 ${isPausedAtEvent ? (mode==='meeting'?'bg-blue-500 hover:bg-blue-600':'bg-stone-400 hover:bg-stone-500') : (isRunning?'bg-amber-400 hover:bg-amber-500':'bg-emerald-500 hover:bg-emerald-600')}`}>
                                {isPausedAtEvent ? (mode === 'meeting' ? <><Icon path={Icons.Continue} /> ç»§ç»­å¥”è·‘</> : <><Icon path={Icons.Reset} /> é‡æ–°å¼€å§‹</>) : (isRunning ? <><Icon path={Icons.Pause} /> æš‚åœ</> : <><Icon path={Icons.Play} /> å¼€å§‹è¿è¡Œ</>)}
                            </button>
                            <button onClick={() => resetPositions(mode, false)} className="bg-white hover:bg-stone-100 text-stone-500 font-bold p-3 md:p-4 rounded-xl shadow border-2 border-stone-100 transition-colors flex items-center gap-2" title="é‡ç½®">
                                <Icon path={Icons.Reset} /> <span>é‡ç½®</span>
                            </button>
                        </div>

                        {/* æ•°æ®é¢æ¿ */}
                        <div className="grid grid-cols-3 gap-2 md:gap-4">
                            <div className="bg-blue-50 text-blue-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center">
                                <span className="text-[10px] md:text-xs font-bold opacity-60 text-center">å°æ˜ç´¯è®¡é‡Œç¨‹</span>
                                <span className="font-mono font-bold text-lg md:text-xl tabular-nums">{Math.round(totalDistA)}</span>
                            </div>
                            <div className="bg-amber-50 text-amber-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center border-2 border-amber-100">
                                <span className="text-[10px] md:text-xs font-bold opacity-60">æ€»æ—¶é—´</span>
                                <span className="font-mono font-bold text-xl md:text-2xl tabular-nums">{currentTime.toFixed(1)}s</span>
                            </div>
                            <div className="bg-rose-50 text-rose-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center">
                                <span className="text-[10px] md:text-xs font-bold opacity-60 text-center">å°çº¢ç´¯è®¡é‡Œç¨‹</span>
                                <span className="font-mono font-bold text-lg md:text-xl tabular-nums">{Math.round(totalDistB)}</span>
                            </div>
                        </div>
                    </div>

                    <footer className="mt-6 mb-4 text-center text-stone-400 text-xs font-bold opacity-80">
                        @å­™ç»´åˆšæ•™è‚²ç ”ç©¶é™¢
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
